{
  "id": "creational-patterns",
  "title": "Creational Design Patterns",
  "description": "Singleton, Factory Method, Abstract Factory, Builder, and Prototype patterns",
  "category": "patterns",
  "cards": [
    {
      "question": "What are Creational Design Patterns and what problem do they solve?",
      "answer": "Creational patterns abstract the instantiation process. They help make a system independent of how objects are created, composed, and represented. Solve: Hide creation logic, reduce coupling to concrete classes.",
      "details": "GoF Creational Patterns: Singleton, Factory Method, Abstract Factory, Builder, Prototype. Benefits: Flexibility in what/how/when objects are created. Use when: Object creation is complex, need to vary the types created, want to defer creation decisions.",
      "category": "Overview"
    },
    {
      "question": "What is the Singleton Pattern and how do you implement it?",
      "answer": "Singleton: Ensure class has only one instance, provide global access point. Implementation: Private constructor, static getInstance() method, static instance variable.",
      "details": "Use when: Exactly one instance needed (configuration, logging, connection pool). Thread-safe approaches: Eager initialization, synchronized getInstance(), double-checked locking, enum singleton. Drawbacks: Global state, hard to test, tight coupling. Modern alternative: Dependency injection with singleton scope.",
      "category": "Singleton"
    },
    {
      "question": "What problems does Singleton Pattern solve and what are its drawbacks?",
      "answer": "Solves: Controlled access to sole instance, reduced namespace pollution, permits variable number of instances, more flexible than class operations. Drawbacks: Hard to unit test, hidden dependencies, global state, violates SRP.",
      "details": "Testing issue: Can't mock singleton easily. Solution: Depend on interface, inject singleton. Alternatives: Monostate pattern, dependency injection. Singleton is often overused - consider if you really need exactly one instance or just want convenient access.",
      "category": "Singleton"
    },
    {
      "question": "What is the Factory Method Pattern?",
      "answer": "Factory Method: Define interface for creating object, let subclasses decide which class to instantiate. Defers instantiation to subclasses. Creator declares factory method, ConcreteCreator implements it.",
      "details": "Structure: Creator (declares factoryMethod()), ConcreteCreator (implements factoryMethod()), Product (interface), ConcreteProduct. Example: Document app - Application.createDocument() overridden by WordApp, PDFApp to create specific document types.",
      "category": "Factory Method"
    },
    {
      "question": "When should you use Factory Method Pattern?",
      "answer": "Use when: Class can't anticipate which objects it must create, class wants subclasses to specify objects created, need to delegate creation to helper subclasses.",
      "details": "Benefits: Removes tight coupling to concrete classes, follows Open-Closed Principle (add new products via new creators). Tradeoff: Requires subclassing. Compare to Abstract Factory: Factory Method uses inheritance, Abstract Factory uses composition.",
      "category": "Factory Method"
    },
    {
      "question": "What is the Abstract Factory Pattern?",
      "answer": "Abstract Factory: Provide interface for creating families of related objects without specifying concrete classes. Factory creates multiple related products that belong together.",
      "details": "Structure: AbstractFactory (declares creation methods for each product type), ConcreteFactory (implements creation for product family), AbstractProduct (interface per product type), ConcreteProduct. Example: GUI factory creating matching Button, Checkbox, TextField for Windows vs Mac.",
      "category": "Abstract Factory"
    },
    {
      "question": "What is the difference between Factory Method and Abstract Factory?",
      "answer": "Factory Method: Creates ONE product, uses inheritance (subclass overrides method). Abstract Factory: Creates FAMILY of related products, uses composition (factory object passed in).",
      "details": "Factory Method: Single method returning product. Abstract Factory: Object with multiple creation methods for related products. Abstract Factory often implemented with Factory Methods. Use Abstract Factory when need to create matched sets of objects.",
      "category": "Factory Comparison"
    },
    {
      "question": "What is the Builder Pattern?",
      "answer": "Builder: Separate construction of complex object from its representation. Same construction process can create different representations. Director orchestrates, Builder creates parts step-by-step.",
      "details": "Structure: Builder (interface for creating parts), ConcreteBuilder (constructs and assembles parts), Director (constructs using builder interface), Product (complex object). Use when: Object has many optional parameters, construction involves multiple steps, want to create different representations.",
      "category": "Builder"
    },
    {
      "question": "When should you use Builder Pattern and what are common implementations?",
      "answer": "Use when: Object construction is complex, many optional parameters, need to construct immutable objects with many fields, want readable object construction code.",
      "details": "Common implementation: Fluent builder with method chaining. Example: new CarBuilder().setEngine('V8').setSeats(4).setGPS(true).build(). Benefits: Avoids telescoping constructors, clearer than big constructor calls, enforces required fields. Java example: StringBuilder.",
      "category": "Builder"
    },
    {
      "question": "What is the Prototype Pattern?",
      "answer": "Prototype: Create new objects by copying existing prototype instance. Client asks prototype to clone itself. Avoids subclassing and expensive creation from scratch.",
      "details": "Structure: Prototype (declares clone interface), ConcretePrototype (implements clone), Client (creates new object by asking prototype to clone). Use when: Object creation is expensive, need copy of existing object, want to avoid subclasses of factories.",
      "category": "Prototype"
    },
    {
      "question": "How does a Prototype cache improve performance?",
      "answer": "Prototype cache stores instance objects (originals) and returns clones on request. Instead of creating a new object from scratch, the system clones a cached prototype, reducing expensive creation costs.",
      "details": "Slides show: store original shape objects in a map/hashtable, and return cloned copies when requested. Use when creation is costly (DB reads, complex setup). Cache reduces DB calls and improves performance.",
      "category": "Prototype"
    },
    {
      "question": "How do you choose which creational pattern to use?",
      "answer": "Singleton: Exactly one instance needed. Factory Method: Subclasses should decide what to create. Abstract Factory: Families of related objects. Builder: Complex construction, many optional parts. Prototype: Create by copying existing object.",
      "details": "Decision factors: Number of products, whether products are related, construction complexity, need for single instance. Patterns can combine: Abstract Factory implemented with Factory Methods, Builder creates Singleton. Start simple, refactor to patterns when needed.",
      "category": "Comparison"
    },
    {
      "question": "Which creational patterns are recommended for the restaurant app scenarios in the slides?",
      "answer": "Slides recommend: Singleton for a multi-threaded backend (shared manager), Factory Method for extensible menu creation, Builder for complex meal assembly, and Prototype for predefined lunch box menus (clone prototypes).",
      "details": "These scenarios illustrate common use cases: Singleton to manage shared state safely; Factory Method to allow extensibility for dish types; Builder to assemble complex orders; Prototype to clone preset meal templates for performance.",
      "category": "Examples"
    },
    {
      "question": "What are the essential elements that describe a design pattern?",
      "answer": "Each pattern should include: a Name, the Problem/Intent, the Solution (structure & participants), and the Consequences (tradeoffs & results).",
      "details": "Slides define pattern elements as Pattern Name, Problem (context), Solution (UML structure or code), and Consequences (benefits, liabilities). These form the minimal documentation for a pattern.",
      "category": "Overview"
    },
    {
      "question": "Give a concrete example of when to use Abstract Factory over Factory Method.",
      "answer": "Abstract Factory: Creating themed UI (Dark theme factory creates dark buttons, dark menus, dark dialogs - all matching). All products must work together. Factory Method: Just need to vary one type of product.",
      "details": "Abstract Factory ensures consistency: If you get a WindowsFactory, all created components (Button, Menu, Dialog) are Windows-style. Factory Method example: Different document types in app - each app subclass creates its own document type but doesn't need matching families.",
      "category": "Comparison"
    }
  ]
}
