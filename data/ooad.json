{
  "id": "ooad",
  "title": "Object-Oriented Analysis & Design",
  "description": "Design principles, GRASP patterns, responsibility assignment, and design class diagrams",
  "category": "design",
  "cards": [
    {
      "question": "What is OOAD and what are its main goals?",
      "answer": "OOAD is a systematic methodology to transform requirements into a robust, implementable software design. Main goals include transforming requirements into design, evolving a robust architecture, and adapting design to the implementation environment.",
      "details": "Slides list main goals: transform requirements into design, evolve robust architecture, and adapt to target technology. OOAD is driven by requirements and produces analysis classes that evolve into design classes.",
      "category": "OOAD Fundamentals",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 10, "endLine": 36 }
    },
    {
      "question": "What are analysis class stereotypes and their roles?",
      "answer": "Three analysis stereotypes: boundary classes (interfaces to actors), control classes (orchestrate use case logic), and entity classes (domain objects with state and lifecycle).",
      "details": "Slides define 'boundary', 'control', and 'entity' stereotypes, recommend one control class per use case, boundary classes per actor/use case pair, and entity classes for enduring domain concepts.",
      "category": "Analysis",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 150, "endLine": 172 }
    },
    {
      "question": "How do you identify candidate analysis classes from use cases?",
      "answer": "Underline noun phrases in the use case specification, apply domain knowledge, and filter out duplicates, implementation constructs, and attributes or operations that are not domain classes.",
      "details": "Slides recommend underlining nouns in use case descriptions, then removing implementation constructs (database, files), duplicates, and attributes; the remaining nouns are candidate entity or domain classes.",
      "category": "Analysis",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 220, "endLine": 236 }
    },
    {
      "question": "What is a control class and what are the two types?",
      "answer": "Control classes coordinate use case behavior; they can be use-case-specific controllers or fa√ßade controllers that represent the system's interface.",
      "details": "Slides recommend one control class per use case and use naming like [UseCaseName]Controller; controllers orchestrate interactions between boundaries and entities, avoiding bloated controllers by delegation.",
      "category": "Analysis",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 252, "endLine": 268 }
    },
    {
      "question": "What is coupling and how do interfaces help reduce it?",
      "answer": "Coupling measures dependencies between components; interface abstraction reduces coupling by defining contracts and hiding implementations behind stable interfaces.",
      "details": "Slides discuss interface abstraction as a mechanism for loose coupling and show that defining subsystem interfaces and using abstraction reduces direct dependencies and eases change.",
      "category": "Design",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 298, "endLine": 304 }
    },
    {
      "question": "What is software architecture and what structural elements does it include?",
      "answer": "Architecture is a set of significant decisions organizing a system; it includes structural elements, interfaces, interactions, composition, patterns, and quality attributes.",
      "details": "Slides define architecture as covering structural elements (components), interfaces, interactions, composition, architectural styles and quality attributes (performance, security, reliability).",
      "category": "Architecture",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 300, "endLine": 326 }
    },
    {
      "question": "How are interaction diagrams used in analysis?",
      "answer": "Use interaction diagrams (sequence and communication diagrams) to model use case behavior, showing interactions, message flows, and the sequence of operations in a use case.",
      "details": "Slides describe modeling behavior with sequence diagrams (time-oriented) and communication diagrams (collaboration view) and advise building one interaction diagram per use case scenario to identify messages and operations.",
      "category": "Analysis",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 170, "endLine": 178 }
    },
    {
      "question": "Why apply design patterns and frameworks during object design?",
      "answer": "Design patterns and frameworks provide proven solutions to recurring problems, support reuse, and help achieve quality attributes required by the system.",
      "details": "Slides recommend identifying applicable design patterns and frameworks during object design to reuse proven solutions and facilitate maintainability and extensibility.",
      "category": "Design",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 560, "endLine": 572 }
    },
    {
      "question": "What are component interfaces and why are they important?",
      "answer": "Component interfaces are communication contracts that define how components interact and hide implementation details, enabling loose coupling between subsystems.",
      "details": "Slides describe component interfaces as contracts and show how defining subsystem interfaces and using interface abstraction reduces direct dependencies between modules.",
      "category": "Design",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 298, "endLine": 368 }
    },
    {
      "question": "What is the 4+1 view model and why use it?",
      "answer": "The 4+1 view model organizes architecture into logical, development, process, and deployment views plus use cases to cover requirements and stakeholder concerns.",
      "details": "Slides explain the 4+1 model: logical (structure & behavior), development (modules), process (concurrency), deployment (distribution), and use cases (requirements). It helps address different stakeholder needs.",
      "category": "Architecture",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 320, "endLine": 338 }
    },
    {
      "question": "How do you create a Design Class Diagram from a Domain Model?",
      "answer": "Start from domain (analysis) classes, extract operations and associations from interaction diagrams, identify multiplicities and roles, and then refine with design classes or patterns as needed.",
      "details": "Slides recommend: 1) start with analysis/domain classes; 2) extract operations from messages and associations from links; 3) identify multiplicities and navigation; 4) refine by adding design classes or patterns. See also the 'Deriving Class Diagrams from Interaction Diagrams' example in the OO A slides.",
      "category": "Design",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 176, "endLine": 188 }
    },
    {
      "question": "What is the relationship between sequence diagrams and class diagrams in design?",
      "answer": "Sequence diagrams show dynamic interactions (messages) for a scenario; class diagrams show the static structure. Messages in sequence diagrams map to operations on the receiver classes in the class diagram.",
      "details": "Slides show a 'From Messages to Operations' process: extract each message from interaction diagrams and create the corresponding operation in the receiving class; this is the typical workflow for deriving class diagrams.",
      "category": "Design",
      "slide_ref": { "file": "wk_5-1_ooa.md", "startLine": 484, "endLine": 508 }
    },
    {
      "question": "What are the design goals used to guide OOAD architecture decisions?",
      "answer": "Design goals include meeting quality attributes like performance, security, reliability, modifiability, and extensibility while keeping structure manageable.",
      "details": "Slides recommend identifying quality attributes, decomposing into subsystems, refining architecture with patterns, and selecting interface contracts aligned with quality requirements.",
      "category": "Design Principles",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 280, "endLine": 306 }
    },
    {
      "question": "How do you evaluate design quality?",
      "answer": "Evaluate whether a design meets specified quality attributes, reduces duplication, provides modularity, and supports maintainability and testability.",
      "details": "Slides advise evaluating design by checking alignment with requirements and quality attributes, verifying subsystem decomposition, patterns used, and whether interfaces support loose coupling and maintainability.",
      "category": "Design Principles",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 280, "endLine": 312 }
    },
    {
      "question": "How and when do you use composition to organize elements?",
      "answer": "Composition combines elements into larger subsystems or structures; use composition to group related functionality and create reusable components with well-defined boundaries.",
      "details": "Slides describe composition as 'How elements combine into larger subsystems' and discuss mapping logical view decomposition into composable components for modularity and reuse.",
      "category": "Design Principles",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 230, "endLine": 240 }
    },
    {
      "question": "What is an interface in system design and why is it useful?",
      "answer": "An interface is a communication contract that defines how components interact without exposing implementation details, promoting loose coupling and substitutability.",
      "details": "Slides show interfaces as key artifacts in the development view, giving example interfaces (BillingService, CourseCatalog) and explain that interfaces support decoupling and integration between components.",
      "category": "Design Principles",
      "slide_ref": { "file": "wk_6-1_ooad.md", "startLine": 360, "endLine": 368 }
    }
  ]
}
