{
  "id": "apis",
  "title": "APIs & Web Services",
  "description": "REST APIs, API design principles, mashups, integration patterns, and API security",
  "category": "integration",
  "cards": [
    {
      "question": "What is a Web API and what does it enable?",
      "answer": "A Web API is an interface exposed over HTTP that allows programs to interact with a web service or browser API. It enables programmatic access to services, integration between systems, third-party development, data sharing, and mashups.",
      "details": "Web APIs provide representations (JSON, XML, HTML) and use HTTP methods for interaction. They are key enablers of mashups and service composition covered in the course.",
      "category": "Fundamentals"
    },
    {
      "question": "What is REST and what are its core principles?",
      "answer": "REST (Representational State Transfer): Architectural style for web services. Principles: Client-server, Stateless, Cacheable, Uniform interface, Layered system, Code on demand (optional).",
      "details": "Uniform interface constraints: Resource identification (URIs), Resource manipulation through representations, Self-descriptive messages, HATEOAS (hypermedia as engine of application state). REST is style, not protocol - typically uses HTTP.",
      "category": "REST"
    },
    {
      "question": "What are HTTP methods and how do they map to CRUD operations?",
      "answer": "GET = Read (safe, idempotent). POST = Create. PUT = Update/Replace (idempotent). PATCH = Partial update. DELETE = Delete (idempotent). Safe: No side effects. Idempotent: Same result if repeated.",
      "details": "GET: Cacheable, should not modify state. POST: Not idempotent - creates new resource each time. PUT: Replaces entire resource, idempotent. PATCH: Updates specific fields. DELETE: Idempotent - deleting twice same effect. Use correct method for semantic meaning.",
      "category": "REST"
    },
    {
      "question": "What are HTTP status codes and which should you use?",
      "answer": "1xx: Informational. 2xx: Success (200 OK, 201 Created, 204 No Content). 3xx: Redirection. 4xx: Client error (400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found). 5xx: Server error (500 Internal Server Error).",
      "details": "Use appropriate codes: 200 for successful GET/PUT. 201 for successful POST (new resource). 204 for successful DELETE (no body). 400 for validation errors. 401 for authentication required. 403 for forbidden (authenticated but not authorized). 404 for not found. 422 for validation failure.",
      "category": "REST"
    },
    {
      "question": "How should you design REST API URLs/endpoints?",
      "answer": "Use nouns for resources, not verbs. Plural names. Hierarchical for relationships. Examples: /users, /users/{id}, /users/{id}/orders. Use query params for filtering/sorting: /users?status=active&sort=name.",
      "details": "Bad: /getUsers, /createUser. Good: GET /users, POST /users. Hierarchy shows relationships: /users/123/orders = orders for user 123. Keep URLs simple, consistent. Version in URL (/v1/users) or header. Avoid deep nesting (max 2-3 levels).",
      "category": "API Design"
    },
    {
      "question": "Why is API versioning a problem and how can developers mitigate version incompatibility?",
      "answer": "Version changes can break clients and mashups, because different consumers may rely on different behaviors. Mitigations include using well-documented APIs, monitoring deprecations, abstracting API calls behind adapters, planning version transitions, and implementing fallback behavior.",
      "details": "Course slides highlight 'Lack of Standards' and 'Version Incompatibility' as key issues and recommend adopting well-documented, stable APIs and designing for graceful migration.",
      "category": "API Design"
    },
    {
      "question": "What is a Mashup and what are the types?",
      "answer": "Mashup: Web application combining data/functionality from multiple sources into single integrated experience. Types: Data mashups, Consumer mashups, Business mashups.",
      "details": "Examples: Real estate site with Google Maps + MLS listings. Travel site combining flights, hotels, reviews. Weather overlay on event calendar. Challenges: API compatibility, data format differences, rate limits, authentication across services, error handling.",
      "category": "Mashups"
    },
    {
      "question": "What security concerns should you consider when integrating external APIs and how can you mitigate them?",
      "answer": "Security concerns include trust of external sources, data exposure, injection attacks, policy or license changes, and accidental leakage of sensitive data. Mitigations: use well-known/trusted APIs, validate and sanitize inputs, limit data exposure, cache or store only essential info, review API terms, and monitor service health.",
      "details": "Slides discuss 'Unknown Sources', 'API misunderstanding', 'Data exposure', and 'Injection Attacks' as key concerns and recommend using trusted providers, input validation, regular security audits, and limiting data exposure.",
      "category": "Security"
    },
    {
      "question": "What role do authentication and authorization play in API security?",
      "answer": "Authentication verifies the identity of a client or user; authorization determines what the authenticated principal is allowed to do. Both are essential: authentication to prevent unauthorized access and authorization to enforce access control rules.",
      "details": "Slides emphasize 'Security' (authentication and authorization) as critical to protect data and system integrity. Best practices include using HTTPS, enforcing server-side access control, and limiting token exposure.",
      "category": "Security"
    },
    {
      "question": "How can you mitigate availability and performance issues when integrating external APIs?",
      "answer": "Use caching for stable data, implement timeouts and retries with exponential backoff, provide fallbacks or degraded modes, monitor downstream service health, and design APIs to fail gracefully when external dependencies are unavailable.",
      "details": "Course slides recommend caching, fallbacks, service health monitoring, and abstracting API calls to reduce direct coupling to external providers.",
      "category": "Resilience"
    },
    {
      "question": "What is the simplest way to embed external content in a page, and what are the trade-offs compared to integrating APIs?",
      "answer": "Embedding via iframes is simple and quick but limits integration and data exchange between sources. Direct API integration allows composing and transforming data but requires more development and depends on APIs' availability and stability.",
      "details": "Slides explain iFrame embedding as a straightforward, low-integration approach, versus data aggregation & API integration that requires fetch/transform logic and offers more control.",
      "category": "Mashups"
    },
    {
      "question": "How do APIs typically signal errors and which HTTP status codes are commonly used?",
      "answer": "APIs use HTTP status codes (e.g., 400, 401, 403, 404, 500) and often return a JSON body with an error message. Use 200/201 for success, 201 for created, 204 for no content, 400 for bad request, 401 for unauthorized, 403 for forbidden, 404 for not found, and 500 for server errors.",
      "details": "Slides show JSON-based error responses in examples and cover status codes. Keep responses concise and avoid exposing internal stack traces while providing enough info for debugging.",
      "category": "API Design"
    },
    {
      "question": "How can query parameters like 'limit' and 'category' be used to control results in a REST API?",
      "answer": "Use query parameters to filter and limit results, e.g., /fruits/list?category=fruit&limit=20. Use sensible defaults and caps to prevent huge responses and support sorting/filtering via additional query params.",
      "details": "Slides show URL examples with query strings for filtering and limiting results. This lightweight approach supports basic pagination and filtering strategies taught in class.",
      "category": "API Design"
    },
    {
      "question": "What is HATEOAS and how does it relate to REST?",
      "answer": "HATEOAS (Hypermedia As The Engine Of Application State) means servers include links in resource representations that indicate available next actions, enabling discoverability and reducing coupling between client and server.",
      "details": "Slides introduce HATEOAS as a uniform interface constraint of REST where resource representations include transitions (links) to guide client interaction.",
      "category": "REST"
    },
    {
      "question": "How do you design APIs for reliability and resilience?",
      "answer": "Idempotency: Safe to retry. Timeouts: Don't wait forever. Retries: Exponential backoff. Circuit breaker: Fail fast when dependency down. Graceful degradation: Return partial results.",
      "details": "Idempotency keys: Client-generated ID to prevent duplicate processing. Circuit breaker states: Closed (normal), Open (failing fast), Half-open (testing). Health endpoints: /health for monitoring. Rate limit responses with Retry-After header. Document expected behavior.",
      "category": "Resilience"
    }
  ]
}
