{
  "id": "architectural-styles",
  "title": "Software Architectural Styles",
  "description": "Layered, client-server, MVC, microservices, event-driven, and other architectural patterns",
  "category": "architecture",
  "cards": [
    {
      "question": "What is an Architectural Style/Pattern and how do you choose one?",
      "answer": "Architectural style: Recurring organization of components and connectors that solves common problems. Choose based on: Quality attributes needed, problem domain, team expertise, constraints.",
      "details": "Styles provide proven solutions to architectural problems. Most systems combine multiple styles. Selection criteria: Scalability needs, team distribution, performance requirements, maintainability priorities, integration needs. No universal 'best' style.",
      "category": "Fundamentals"
    },
    {
      "question": "What is Layered Architecture and what are its benefits/drawbacks?",
      "answer": "Layered: System organized in horizontal layers, each providing services to layer above. Common: Presentation → Business Logic → Data Access → Database. Benefits: Separation of concerns, testability. Drawbacks: Performance overhead, rigid structure.",
      "details": "Slides: Multi-level client-server; each layer exposes APIs to the higher layer; common 3-tier web applications follow this model. Benefits: separation of concerns, team parallelism. Drawbacks: performance overhead and straddling issues for cross-cutting requests.",
      "category": "Layered"
    },
    {
      "question": "What is Client-Server Architecture?",
      "answer": "Client-Server: Clients request services from centralized servers. Server manages shared resources. Benefits: Centralized data, easier maintenance, security control. Drawbacks: Server bottleneck, single point of failure.",
      "details": "Variations: Thin client (minimal client logic), Thick/Fat client (significant client processing), 2-tier (direct DB access), 3-tier/n-tier (middle tier). Modern web apps are client-server with browser as client, web server providing API.",
      "category": "Client-Server"
    },
    {
      "question": "What is MVC (Model-View-Controller) and how do components interact?",
      "answer": "MVC separates: Model (data/logic), View (presentation), Controller (handles input, coordinates). User → Controller → Model → View → User. Benefits: Separation of concerns, multiple views of same data, parallel development.",
      "details": "Model: Business logic, data, state - no UI knowledge. View: Displays model data - no business logic. Controller: Handles input, updates model, selects view. Variations: MVP (Presenter mediates), MVVM (ViewModel with binding). Web MVC: Request → Controller → Model → View → Response.",
      "category": "MVC"
    },
    {
      "question": "What is Microservices Architecture and when should you use it?",
      "answer": "Microservices: System as collection of small, independently deployable services, each running its own process, communicating via lightweight protocols (HTTP/messaging). Use when: Need independent scaling, large teams, frequent deployment.",
      "details": "Characteristics: Single responsibility per service, own database, API-based communication, decentralized governance. Benefits: Scalability, technology diversity, team autonomy, fault isolation. Drawbacks: Distributed system complexity, network latency, data consistency challenges, operational overhead.",
      "category": "Microservices"
    },
    {
      "question": "What is the difference between Microservices and Monolithic architecture?",
      "answer": "Monolith: Single deployable unit, shared database, in-process calls. Microservices: Multiple deployable units, database per service, network calls. Monolith simpler to start, Microservices scale better.",
      "details": "Start monolithic, extract microservices when needed (Martin Fowler). Microservice tradeoffs: Distributed transactions, eventual consistency, service discovery, API versioning. Monolith tradeoffs: Harder to scale specific functions, technology lock-in, deployment coupling.",
      "category": "Microservices"
    },
    {
      "question": "What is Event-Driven Architecture (EDA)?",
      "answer": "EDA: Components communicate through events — asynchronous messages indicating that something has happened. Producers publish events; consumers react. Benefits include loose coupling, scalability, and responsiveness.",
      "details": "Slides: Event-based systems commonly use message brokers, event buses, and pub/sub systems (RabbitMQ, Kafka). Debugging and ordering are common challenges; systems often adopt eventual consistency patterns.",
      "category": "Event-Driven"
    },
    {
      "question": "What is Pipe and Filter Architecture?",
      "answer": "Pipe and Filter: Data flows through sequence of processing components (filters) connected by pipes. Each filter transforms data and passes to next. Benefits: Reusability, parallelism, flexibility in recombining filters.",
      "details": "Examples: Unix commands (ls | grep | sort), compilers (lexer → parser → optimizer → code gen), data processing pipelines. Filters should be independent, no shared state. Drawbacks: Overhead of data transformation, not good for interactive systems.",
      "category": "Pipe and Filter"
    },
    {
      "question": "What is Service-Oriented Architecture (SOA)?",
      "answer": "SOA: System as collection of services that communicate over network. Services are self-contained, have defined interfaces, can be discovered and composed. Precursor to microservices.",
      "details": "SOA vs Microservices: SOA typically uses ESB (Enterprise Service Bus), shared databases, SOAP/XML. Microservices: Lightweight protocols, database per service, REST/JSON. SOA often for enterprise integration. Both promote loose coupling and reusability.",
      "category": "SOA"
    },
    {
      "question": "What is Cloud/Fog/Edge computing and when should you use it?",
      "answer": "Cloud: on-demand virtualized resources managed by providers. Fog: middle layer bringing cloud capabilities closer to the edge. Edge: computation near devices for low latency and reduced bandwidth usage. Use when you need low latency, local processing, or bandwidth reduction for IoT and real-time systems.",
      "details": "Slides explain Cloud/Fog/Edge: Cloud provides central processing and storage, Fog provides specialized middle-layer services, Edge processes data near devices. Benefits: lower latency, reduced bandwidth, improved reliability, and privacy benefits for local processing.",
      "category": "Cloud/Edge"
    },
    {
      "question": "What is Broker Architecture and how does it support service discovery?",
      "answer": "Broker Mediates service invocation: servers register capabilities with the broker; clients query the broker to discover and invoke services. Brokers route requests, enabling dynamic service location, load balancing, and decoupling clients from server addresses.",
      "details": "Slides show Broker: clients query broker for service locations; brokers may route requests or return addresses for direct invocation. Examples: CORBA object brokers, microservices service registries, API gateways. Advantages: decoupling and flexible routing. Disadvantages: broker bottlenecks and added complexity.",
      "category": "Broker"
    },
    {
      "question": "What is Peer-to-Peer architecture and why choose it?",
      "answer": "Peer-to-Peer: Decentralized network with independent peer nodes that can act as clients and servers. Offers resilience (no single point of failure) and scalable resources as peers join. Use for distributed storage, file sharing, and decentralized applications.",
      "details": "Slides explain P2P characteristics: peers have own state, dynamic roles, and distributed registries for discovery. Advantages: high robustness and scalability. Disadvantages: complex coordination, security challenges, and unpredictable availability.",
      "category": "P2P"
    },
    {
      "question": "What is Blackboard architecture and where is it applicable?",
      "answer": "Blackboard architecture uses a shared central data structure (the blackboard) where specialists read/write partial results to iteratively solve a problem. It suits complex AI tasks like speech recognition, vision, or diagnosis where multiple techniques collaborate.",
      "details": "Slides describe a central blackboard that stores problem state and partial solutions. Specialists watch the blackboard and contribute their computations. Advantages: loose coupling and flexible problem solving; disadvantages: coordination complexity and non-deterministic performance.",
      "category": "Blackboard"
    },
    {
      "question": "How do you compare architectural styles for a given problem?",
      "answer": "Compare based on: Quality attribute impact (scalability, maintainability, performance), team capabilities, operational requirements, integration needs, time/budget constraints, expected evolution.",
      "details": "Create comparison matrix: List styles vs. criteria. Score each combination. Consider: What's most important for this system? What constraints exist? What's team's experience? No perfect style - understand tradeoffs. Document decision in ADR.",
      "category": "Decision Making"
    },
    {
      "question": "What is the difference between synchronous and asynchronous architectural communication?",
      "answer": "Synchronous: Caller waits for response (HTTP request/response, RPC). Asynchronous: Caller continues without waiting (message queues, events). Choose based on: Coupling needs, performance, reliability requirements.",
      "details": "Sync benefits: Simpler programming model, immediate feedback. Async benefits: Better decoupling, handles load spikes, fault tolerance. Async challenges: Complexity, eventual consistency, harder debugging. Many systems use both - sync for queries, async for commands/events.",
      "category": "Communication"
    }
  ]
}
